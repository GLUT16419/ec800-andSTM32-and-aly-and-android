# 多渠道告警功能实现方案

## 一、当前系统架构分析

### 1.1 现有告警系统组件

**AlertService.kt**
- 已实现告警渠道枚举（LOCAL_NOTIFICATION、EMAIL、SMS、PUSH_NOTIFICATION）
- 告警配置类（AlertConfig）支持多渠道配置
- 事件日志订阅机制
- 告警去重逻辑（5分钟内不重复告警同一事件）
- 本地通知渠道已完整实现
- 邮件、短信、推送通知渠道仅为模拟实现

**EventLogger.kt**
- 事件日志级别（INFO、WARNING、ERROR、CRITICAL）
- 事件类型定义（设备离线、传感器告警等）
- 事件持久化存储
- 实时事件通知机制

**项目文档**
- 已包含事件日志系统描述
- 缺少多渠道告警的详细实现说明

### 1.2 当前系统限制

1. **邮件告警**：仅模拟实现，无实际邮件发送功能
2. **短信告警**：仅模拟实现，无实际短信发送功能
3. **推送通知**：仅模拟实现，无实际推送能力
4. **配置界面**：缺少告警渠道配置的用户界面
5. **接收人管理**：缺少接收人添加、删除、验证功能

## 二、多渠道告警实现方案

### 2.1 邮件告警实现

#### 2.1.1 技术选型
- **JavaMail API**：标准Java邮件发送库，无需额外依赖
- **SMTP服务器**：建议使用企业邮箱或第三方邮件服务（如SendGrid）

#### 2.1.2 实现步骤

1. **添加依赖**
   ```gradle
   // 无需额外依赖，Android已内置JavaMail API相关类
   ```

2. **完善sendEmailAlert方法**
   ```kotlin
   private fun sendEmailAlert(eventLog: EventLogEntity) {
       coroutineScope.launch(Dispatchers.IO) {
           try {
               val config = _alertConfig.value ?: return@launch
               if (config.recipients.isEmpty()) return@launch
               
               // 邮件服务器配置
               val props = Properties().apply {
                   put("mail.smtp.host", "smtp.example.com")
                   put("mail.smtp.port", "587")
                   put("mail.smtp.auth", "true")
                   put("mail.smtp.starttls.enable", "true")
               }
               
               // 邮件认证
               val session = Session.getInstance(props, object : Authenticator() {
                   override fun getPasswordAuthentication() = 
                       PasswordAuthentication("alert@coldchain.com", "password")
               })
               
               // 构建邮件内容
               val message = MimeMessage(session).apply {
                   setFrom(InternetAddress("alert@coldchain.com"))
                   setRecipients(Message.RecipientType.TO, 
                       InternetAddress.parse(config.recipients.joinToString()))
                   subject = "[冷链告警] ${eventLog.type} - ${EventLevel.values().find { it.value == eventLog.level }?.name}"
                   
                   // 富文本邮件内容
                   val content = Multipart().apply {
                       val textPart = MimeBodyPart().apply {
                           setContent(buildString {
                               appendLine("<h3>冷链设备告警通知</h3>")
                               appendLine("<p><strong>告警时间：</strong>${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date(eventLog.timestamp))}</p>")
                               appendLine("<p><strong>告警级别：</strong>${EventLevel.values().find { it.value == eventLog.level }?.name}</p>")
                               appendLine("<p><strong>告警类型：</strong>${eventLog.type}</p>")
                               appendLine("<p><strong>告警消息：</strong>${eventLog.message}</p>")
                               eventLog.deviceId?.let { appendLine("<p><strong>设备ID：</strong>$it</p>") }
                               eventLog.details?.let { appendLine("<p><strong>详细信息：</strong>$it</p>") }
                               appendLine("<p><em>此邮件为系统自动发送，请勿回复</em></p>")
                           }, "text/html; charset=utf-8")
                       }
                       addBodyPart(textPart)
                   }
                   setContent(content)
               }
               
               // 发送邮件
               Transport.send(message)
               
               Log.i(TAG, "邮件告警已发送到: ${config.recipients.joinToString()}")
               eventLogger.info(EventType.SYSTEM_EVENT, "邮件告警发送成功", "收件人: ${config.recipients.joinToString()}")
           } catch (e: Exception) {
               Log.e(TAG, "发送邮件告警失败", e)
               eventLogger.logException(EventType.SYSTEM_EVENT, "发送邮件告警失败", e)
           }
       }
   }
   ```

3. **配置管理**
   - 在AlertConfig中添加邮件服务器配置字段
   - 实现邮件配置的持久化存储

### 2.2 短信告警实现

#### 2.2.1 技术选型
- **阿里云短信服务**：成熟稳定，支持国内国际短信
- **腾讯云短信**：性价比高，集成简单

#### 2.2.2 实现步骤

1. **添加依赖**
   ```gradle
   // 阿里云短信SDK
   implementation 'com.aliyun:aliyun-java-sdk-core:4.6.0'
   implementation 'com.aliyun:aliyun-java-sdk-dysmsapi:2.1.0'
   ```

2. **完善sendSmsAlert方法**
   ```kotlin
   private fun sendSmsAlert(eventLog: EventLogEntity) {
       coroutineScope.launch(Dispatchers.IO) {
           try {
               val config = _alertConfig.value ?: return@launch
               if (config.recipients.isEmpty()) return@launch
               
               // 阿里云短信配置
               val profile = DefaultProfile.getProfile(
                   "cn-hangzhou", // 地域ID
                   "accessKeyId", // 阿里云accessKey
                   "accessKeySecret" // 阿里云accessKeySecret
               )
               
               val client = DefaultAcsClient(profile)
               val request = SendSmsRequest().apply {
                   phoneNumbers = config.recipients.joinToString() // 手机号列表
                   signName = "冷链监控系统" // 短信签名
                   templateCode = "SMS_123456789" // 短信模板ID
                   
                   // 模板参数
                   val templateParam = buildJsonObject {
                       put("message", eventLog.message)
                       put("level", EventLevel.values().find { it.value == eventLog.level }?.name)
                       put("time", SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date(eventLog.timestamp)))
                       eventLog.deviceId?.let { put("deviceId", it) }
                   }.toString()
                   
                   setTemplateParam(templateParam)
               }
               
               // 发送短信
               val response = client.getAcsResponse(request)
               
               if (response.code == "OK") {
                   Log.i(TAG, "短信告警已发送到: ${config.recipients.joinToString()}, 短信ID: ${response.bizId}")
                   eventLogger.info(EventType.SYSTEM_EVENT, "短信告警发送成功", "收件人: ${config.recipients.joinToString()}, 短信ID: ${response.bizId}")
               } else {
                   Log.e(TAG, "发送短信告警失败: ${response.message}")
                   eventLogger.error(EventType.SYSTEM_EVENT, "发送短信告警失败", response.message)
               }
           } catch (e: Exception) {
               Log.e(TAG, "发送短信告警失败", e)
               eventLogger.logException(EventType.SYSTEM_EVENT, "发送短信告警失败", e)
           }
       }
   }
   ```

3. **配置管理**
   - 在AlertConfig中添加短信服务配置字段
   - 实现短信配置的持久化存储

### 2.3 推送通知实现

#### 2.3.1 技术选型
- **极光推送**：国内主流推送服务，支持Android/iOS
- **阿里云推送**：与阿里云IoT平台集成良好

#### 2.3.2 实现步骤

1. **添加依赖**
   ```gradle
   // 极光推送SDK
   implementation 'cn.jiguang.sdk:jpush:4.8.0'
   implementation 'cn.jiguang.sdk:jcore:4.6.0'
   ```

2. **完善sendPushNotification方法**
   ```kotlin
   private fun sendPushNotification(eventLog: EventLogEntity) {
       coroutineScope.launch(Dispatchers.IO) {
           try {
               // 构建推送消息
               val pushPayload = PushPayload.newBuilder()
                   .setPlatform(Platform.android())
                   .setAudience(Audience.all()) // 所有设备
                   // .setAudience(Audience.alias("user123")) // 指定用户
                   .setNotification(Notification.newBuilder()
                       .setAlert(eventLog.message)
                       .addPlatformNotification(AndroidNotification.newBuilder()
                           .setTitle("[${EventLevel.values().find { it.value == eventLog.level }?.name}] 冷链设备告警")
                           .setPriority(1)
                           .addExtra("eventType", eventLog.type)
                           .addExtra("eventId", eventLog.id)
                           .build())
                       .build())
                   .build()
               
               // 发送推送
               val result = JPushClient.sendPush(pushPayload)
               
               if (result.isResultOK) {
                   Log.i(TAG, "推送通知已发送: ${eventLog.message}, 消息ID: ${result.msgId}")
                   eventLogger.info(EventType.SYSTEM_EVENT, "推送通知发送成功", "消息ID: ${result.msgId}")
               } else {
                   Log.e(TAG, "发送推送通知失败: ${result.errorCode}:${result.errorMessage}")
                   eventLogger.error(EventType.SYSTEM_EVENT, "发送推送通知失败", "${result.errorCode}:${result.errorMessage}")
               }
           } catch (e: Exception) {
               Log.e(TAG, "发送推送通知失败", e)
               eventLogger.logException(EventType.SYSTEM_EVENT, "发送推送通知失败", e)
           }
       }
   }
   ```

3. **配置管理**
   - 在AndroidManifest.xml中配置推送服务
   - 实现推送配置的持久化存储

## 三、告警配置界面实现

### 3.1 界面设计

**告警设置页面**
- 总开关：启用/禁用所有告警
- 渠道选择：勾选需要启用的告警渠道
- 告警级别：设置触发告警的最低级别
- 告警间隔：设置告警去重时间间隔
- 接收人管理：添加/删除邮件/短信接收人
- 设备选择：选择需要监控的设备（为空表示所有设备）

### 3.2 实现步骤

1. **创建AlertSettingFragment**
   ```kotlin
   class AlertSettingFragment : Fragment() {
       private lateinit var alertService: AlertService
       private lateinit var binding: FragmentAlertSettingBinding
       
       override fun onCreateView(...): View {
           binding = FragmentAlertSettingBinding.inflate(inflater, container, false)
           alertService = AlertService.getInstance(requireContext())
           return binding.root
       }
       
       override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
           super.onViewCreated(view, savedInstanceState)
           setupUI()
           loadConfig()
       }
       
       // 其他方法...
   }
   ```

2. **实现配置加载与保存**
   ```kotlin
   private fun loadConfig() {
       alertService.alertConfig.observe(viewLifecycleOwner) {
           binding.switchEnableAlerts.isChecked = it.isEnabled
           binding.checkboxEmail.isChecked = it.channels.contains(AlertChannel.EMAIL)
           binding.checkboxSms.isChecked = it.channels.contains(AlertChannel.SMS)
           binding.checkboxPush.isChecked = it.channels.contains(AlertChannel.PUSH_NOTIFICATION)
           binding.spinnerAlertLevel.setSelection(it.minLevel.ordinal)
           binding.editTextAlertInterval.setText((it.alertInterval / 1000 / 60).toString())
           updateRecipientList(it.recipients)
       }
   }
   
   private fun saveConfig() {
       val config = alertService.alertConfig.value?.copy() ?: AlertConfig()
       config.isEnabled = binding.switchEnableAlerts.isChecked
       config.channels.clear()
       
       if (binding.checkboxLocalNotification.isChecked) config.channels.add(AlertChannel.LOCAL_NOTIFICATION)
       if (binding.checkboxEmail.isChecked) config.channels.add(AlertChannel.EMAIL)
       if (binding.checkboxSms.isChecked) config.channels.add(AlertChannel.SMS)
       if (binding.checkboxPush.isChecked) config.channels.add(AlertChannel.PUSH_NOTIFICATION)
       
       config.minLevel = EventLevel.values()[binding.spinnerAlertLevel.selectedItemPosition]
       config.alertInterval = binding.editTextAlertInterval.text.toString().toLong() * 60 * 1000
       config.recipients.clear()
       config.recipients.addAll(recipientList)
       
       alertService.updateConfig(config)
   }
   ```

3. **实现接收人管理**
   ```kotlin
   private fun updateRecipientList(recipients: List<String>) {
       recipientList.clear()
       recipientList.addAll(recipients)
       binding.recyclerViewRecipients.adapter?.notifyDataSetChanged()
   }
   
   private fun addRecipient() {
       val recipient = binding.editTextNewRecipient.text.toString().trim()
       if (recipient.isNotEmpty() && isValidRecipient(recipient)) {
           recipientList.add(recipient)
           binding.recyclerViewRecipients.adapter?.notifyItemInserted(recipientList.size - 1)
           binding.editTextNewRecipient.text.clear()
       } else {
           Toast.makeText(requireContext(), "请输入有效的邮箱或手机号", Toast.LENGTH_SHORT).show()
       }
   }
   
   private fun isValidRecipient(recipient: String): Boolean {
       // 验证邮箱或手机号格式
       val emailPattern = "[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}".toRegex()
       val phonePattern = "1[3-9]\\d{9}".toRegex()
       return emailPattern.matches(recipient) || phonePattern.matches(recipient)
   }
   ```

## 四、项目文档更新

### 4.1 更新内容

**章节3.8 多渠道告警系统**

```markdown
### 3.8 多渠道告警系统
- **功能**：实现设备异常的多渠道告警通知，支持本地通知、邮件、短信、推送通知
- **实现**：
  - 告警服务（AlertService）作为核心控制器
  - 事件日志触发告警机制
  - 告警去重逻辑（可配置时间间隔）
  - 多渠道并行发送
  - 接收人管理功能

#### 3.8.1 告警渠道

| 渠道类型 | 实现方式 | 技术选型 | 用途 |
|---------|---------|---------|------|
| 本地通知 | 完整实现 | Android Notification API | 应用内实时提醒 |
| 邮件告警 | 完整实现 | JavaMail API | 重要事件邮件通知 |
| 短信告警 | 完整实现 | 阿里云短信服务 | 紧急事件短信通知 |
| 推送通知 | 完整实现 | 极光推送 | 离线状态推送提醒 |

#### 3.8.2 告警配置

```kotlin
// 告警配置类
data class AlertConfig(
    var isEnabled: Boolean = true,
    val channels: MutableSet<AlertChannel> = mutableSetOf(AlertChannel.LOCAL_NOTIFICATION),
    val minLevel: EventLevel = EventLevel.WARNING,
    val deviceIds: MutableSet<Int> = mutableSetOf(), // 为空表示所有设备
    val alertInterval: Long = 5 * 60 * 1000L, // 默认5分钟内不重复告警同一事件
    val recipients: MutableList<String> = mutableListOf() // 邮件/短信收件人
)
```

#### 3.8.3 邮件告警实现

```kotlin
private fun sendEmailAlert(eventLog: EventLogEntity) {
    coroutineScope.launch(Dispatchers.IO) {
        // 邮件发送逻辑
        // ...
    }
}
```

#### 3.8.4 短信告警实现

```kotlin
private fun sendSmsAlert(eventLog: EventLogEntity) {
    coroutineScope.launch(Dispatchers.IO) {
        // 短信发送逻辑
        // ...
    }
}
```

#### 3.8.5 推送通知实现

```kotlin
private fun sendPushNotification(eventLog: EventLogEntity) {
    coroutineScope.launch(Dispatchers.IO) {
        // 推送通知逻辑
        // ...
    }
}
```
```

### 4.2 配置文件更新

**build.gradle（Module）**
```gradle
// 添加短信服务依赖
implementation 'com.aliyun:aliyun-java-sdk-core:4.6.0'
implementation 'com.aliyun:aliyun-java-sdk-dysmsapi:2.1.0'

// 添加推送服务依赖
implementation 'cn.jiguang.sdk:jpush:4.8.0'
implementation 'cn.jiguang.sdk:jcore:4.6.0'
```

**AndroidManifest.xml**
```xml
<!-- 极光推送配置 -->
<meta-data android:name="JPUSH_CHANNEL" android:value="developer-default" />
<meta-data android:name="JPUSH_APPKEY" android:value="your_app_key" />

<!-- 阿里云短信服务不需要额外配置 -->
```

## 五、安全性考虑

1. **API密钥管理**
   - 邮件服务器密码、短信服务密钥等敏感信息应加密存储
   - 避免硬编码敏感信息，使用安全的配置管理方式

2. **权限控制**
   - 本地通知权限申请
   - 网络访问权限
   - 后台服务权限

3. **数据传输安全**
   - 邮件发送使用TLS加密
   - 短信服务使用HTTPS API
   - 推送服务使用加密传输

4. **隐私保护**
   - 接收人信息加密存储
   - 严格控制告警信息内容，避免泄露敏感数据

## 六、测试策略

1. **单元测试**
   - 告警配置类测试
   - 告警去重逻辑测试
   - 接收人验证测试

2. **集成测试**
   - 事件日志触发告警测试
   - 多渠道并行发送测试
   - 配置持久化测试

3. **端到端测试**
   - 完整告警流程测试
   - 异常场景测试（网络异常、服务不可用等）
   - 性能测试（大量事件触发告警）

## 七、部署与维护

1. **服务配置**
   - 邮件服务器配置
   - 短信服务账号申请
   - 推送服务账号申请

2. **监控与日志**
   - 告警发送日志记录
   - 服务可用性监控
   - 异常告警统计

3. **更新与升级**
   - 第三方服务SDK版本管理
   - 安全补丁更新
   - 功能扩展规划

## 八、实施计划

| 阶段 | 任务 | 时间 | 责任人 |
|------|------|------|--------|
| 1 | 邮件告警功能实现 | 2天 | 开发工程师 |
| 2 | 短信告警功能实现 | 2天 | 开发工程师 |
| 3 | 推送通知功能实现 | 2天 | 开发工程师 |
| 4 | 告警配置界面开发 | 3天 | 开发工程师 |
| 5 | 接收人管理功能开发 | 2天 | 开发工程师 |
| 6 | 系统集成与测试 | 3天 | 测试工程师 |
| 7 | 项目文档更新 | 1天 | 开发工程师 |
| 8 | 部署与验证 | 1天 | 运维工程师 |

## 九、总结

本方案基于现有告警系统架构，通过集成成熟的第三方服务，实现完整的多渠道告警功能。方案涵盖了技术选型、代码实现、界面设计、文档更新、测试策略等各个方面，确保系统的可靠性、安全性和易用性。

多渠道告警功能的实现将显著提升冷链监控系统的响应能力，确保设备异常能够及时通知相关人员，降低货物损失风险，提高系统的整体可靠性。