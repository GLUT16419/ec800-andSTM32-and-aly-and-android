# 基于物联网的冷藏运输车环境监测与智能管控系统
## Android应用开发文档

## 一、项目概述

### 1.1 项目背景
本项目是一个基于物联网技术的冷藏运输车环境监测与智能管控系统，旨在通过多传感器实时采集数据、借助物联网卡传输、平台端集中管理，实现对冷藏车运输全程的温度、湿度、氧浓度、车辆行驶轨迹等环境监控与异常预警，保障生鲜、药品等货物的品质。

### 1.2 核心功能
- 实时监控冷藏运输设备的环境参数（温度、湿度、氧气浓度）
- 所有冷链设备轨迹实时显示与记录
- 设备状态智能判断与异常预警
- 历史数据查询与统计分析
- 设备管理与筛选功能
- 事件日志记录与查询
- 设备批量操作管理
- 数据持久化存储

### 1.3 技术架构
- **前端**：Android应用（Kotlin）
- **后端**：阿里云IoT平台
- **通信协议**：MQTT
- **地图服务**：高德地图SDK
- **开发框架**：Jetpack组件（LiveData、Coroutine、Room等）
- **架构模式**：MVVM（Model-View-ViewModel）

## 二、系统架构

### 2.1 整体架构
```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  车载终端设备   │     │  阿里云IoT平台  │     │  Android应用    │
│  (传感器集群)   │────>│  (MQTT服务器)   │────>│  (监控客户端)    │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 2.2 Android应用架构
```
┌─────────────────┐
│   LoginActivity │  // 登录界面
└────────┬────────┘
         │
┌────────▼────────┐
│   MainActivity  │  // 主界面容器
├────────┬────────┤
│        │        │        │
▼        ▼        ▼        ▼
HomeFragment DeviceFragment UserFragment EventLogFragment // 底部导航四个主要功能模块
```

### 2.3 MVVM架构
```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│     View        │────>│   ViewModel     │────>│   Repository    │────>│      Model      │
│  (Fragment/     │     │                 │     │                 │     │  (Room/Network) │
│   Activity)     │<────│                 │<────│                 │<────│                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 2.4 核心组件
1. **MqttService**：后台服务，负责与阿里云IoT平台建立MQTT连接、接收数据、解析数据
2. **HomeFragment**：首页地图展示与设备概览，支持设备集群显示
3. **DeviceFragment**：设备列表管理与详细信息查看，支持批量操作
4. **UserFragment**：用户中心与系统设置
5. **EventLogFragment**：事件日志查询与管理
6. **Room数据库**：本地数据持久化，存储设备信息、历史数据和事件日志
7. **EventLogger**：全局事件日志记录器
8. **GlobalExceptionHandler**：全局异常处理机制

## 三、功能模块详解

### 3.1 登录模块
- **功能**：用户身份认证与系统访问控制
- **实现**：LoginActivity作为应用入口，验证用户凭据后跳转到主界面
- **文件**：`app/src/main/java/com/example/dgb/LoginActivity.kt`

### 3.2 实时监控模块
- **功能**：在地图上实时显示设备位置与状态
- **实现**：
  - 使用高德地图SDK展示设备位置标记
  - 根据设备状态显示不同颜色标记（正常/警告/异常）
  - 设备卡片展示关键环境参数
  - 支持地图缩放级别监听，实现多设备聚合显示
- **文件**：`app/src/main/java/com/example/dgb/HomeFragment.kt`
- **布局**：`app/src/main/res/layout/fragment_home.xml`
- **辅助工具**：`app/src/main/java/com/example/dgb/MapUtils.kt`（设备集群显示）

### 3.3 设备管理模块
- **功能**：设备列表展示、搜索、筛选与详情查看
- **实现**：
  - 设备卡片列表展示所有注册设备
  - 支持按设备名称、位置、状态搜索
  - 筛选功能（全部/正常/警告/异常）
  - 点击查看设备历史数据
  - 长按查看设备详细信息
  - 支持设备批量选择和删除操作
- **文件**：`app/src/main/java/com/example/dgb/DeviceFragment.kt`
- **布局**：`app/src/main/res/layout/fragment_device.xml`

### 3.4 MQTT通信模块
- **功能**：与阿里云IoT平台建立连接，接收设备数据
- **实现**：
  - 使用阿里云LinkKit SDK建立MQTT连接
  - 订阅设备数据主题
  - 解析JSON格式的设备数据
  - 更新本地设备列表与状态
  - 异常处理与重连机制
  - 协程处理异步操作
- **文件**：`app/src/main/java/com/example/dgb/MqttService.kt`

### 3.5 数据持久化模块
- **功能**：本地数据存储与管理
- **实现**：
  - 使用Room数据库实现数据持久化
  - 设备信息、历史数据、事件日志的存储与查询
  - DAO模式封装数据库操作
  - Repository模式统一数据访问接口
  - ViewModel实现数据与UI的解耦
- **文件**：
  - 数据库：`app/src/main/java/com/example/dgb/data/DeviceDatabase.kt`
  - DAO：`app/src/main/java/com/example/dgb/data/DeviceDao.kt`、`DeviceHistoryDao.kt`、`EventLogDao.kt`
  - 实体：`app/src/main/java/com/example/dgb/data/DeviceEntity.kt`、`DeviceHistoryEntity.kt`
  - Repository：`app/src/main/java/com/example/dgb/data/DeviceHistoryRepository.kt`
  - ViewModel：`app/src/main/java/com/example/dgb/data/DeviceViewModel.kt`、`DeviceHistoryViewModel.kt`

### 3.6 事件日志系统
- **功能**：记录系统事件、异常信息和用户操作
- **实现**：
  - 全局事件日志记录器
  - 支持不同类型事件的分类记录
  - 事件查询与过滤功能
  - 与Room数据库集成实现持久化
- **文件**：
  - 日志记录器：`app/src/main/java/com/example/dgb/data/EventLogger.kt`
  - 日志界面：`app/src/main/java/com/example/dgb/ui/EventLogFragment.kt`
  - DAO：`app/src/main/java/com/example/dgb/data/EventLogDao.kt`

### 3.7 全局异常处理
- **功能**：捕获和处理应用中的未处理异常
- **实现**：
  - 自定义全局异常处理器
  - 异常信息记录到事件日志
  - 防止应用崩溃提升稳定性
- **文件**：`app/src/main/java/com/example/dgb/data/GlobalExceptionHandler.kt`

### 3.8 多渠道告警系统
- **功能**：实现设备异常的多渠道告警通知，支持本地通知、邮件、短信、推送通知
- **实现**：
  - 告警服务（AlertService）作为核心控制器
  - 事件日志触发告警机制
  - 告警去重逻辑（可配置时间间隔）
  - 多渠道并行发送
  - 接收人管理功能

#### 3.8.1 告警渠道

| 渠道类型 | 实现方式 | 技术选型 | 用途 |
|---------|---------|---------|------|
| 本地通知 | 完整实现 | Android Notification API | 应用内实时提醒 |
| 邮件告警 | 模拟实现 | JavaMail API（待集成） | 重要事件邮件通知 |
| 短信告警 | 模拟实现 | 阿里云短信服务（待集成） | 紧急事件短信通知 |
| 推送通知 | 模拟实现 | 极光推送（待集成） | 离线状态推送提醒 |

#### 3.8.2 告警配置

```kotlin
// 告警配置类
data class AlertConfig(
    var isEnabled: Boolean = true,
    val channels: MutableSet<AlertChannel> = mutableSetOf(AlertChannel.LOCAL_NOTIFICATION),
    val minLevel: EventLevel = EventLevel.WARNING,
    val deviceIds: MutableSet<Int> = mutableSetOf(), // 为空表示所有设备
    val alertInterval: Long = 5 * 60 * 1000L, // 默认5分钟内不重复告警同一事件
    val recipients: MutableList<String> = mutableListOf() // 邮件/短信收件人
)
```

#### 3.8.3 核心实现

**告警服务类（AlertService.kt）**
```kotlin
// 告警渠道枚举
enum class AlertChannel(val value: String) {
    LOCAL_NOTIFICATION("local_notification"),
    EMAIL("email"),
    SMS("sms"),
    PUSH_NOTIFICATION("push_notification")
}

// 事件日志处理
private fun handleEventLog(eventLog: EventLogEntity) {
    val config = _alertConfig.value ?: return
    
    // 检查告警是否启用
    if (!config.isEnabled) return
    
    // 检查事件级别是否达到告警阈值
    val eventLevel = EventLevel.values().find { it.value == eventLog.level } ?: return
    if (eventLevel.value < config.minLevel.value) return
    
    // 检查是否针对特定设备
    if (config.deviceIds.isNotEmpty() && eventLog.deviceId !in config.deviceIds) return
    
    // 检查是否在告警间隔内（去重）
    val alertKey = "${eventLog.type}-${eventLog.deviceId}-${eventLog.level}"
    val lastAlertTime = recentAlerts[alertKey]
    if (lastAlertTime != null && System.currentTimeMillis() - lastAlertTime < config.alertInterval) {
        Log.d(TAG, "告警去重: $alertKey")
        return
    }
    
    // 更新最近告警时间
    recentAlerts[alertKey] = System.currentTimeMillis()
    
    // 发送告警到各个渠道
    config.channels.forEach { channel ->
        when (channel) {
            AlertChannel.LOCAL_NOTIFICATION -> sendLocalNotification(eventLog)
            AlertChannel.EMAIL -> sendEmailAlert(eventLog)
            AlertChannel.SMS -> sendSmsAlert(eventLog)
            AlertChannel.PUSH_NOTIFICATION -> sendPushNotification(eventLog)
        }
    }
}
```

**文件**：`app/src/main/java/com/example/dgb/data/AlertService.kt`

## 四、数据模型

### 4.1 核心数据模型
```kotlin
// 冷链设备数据模型
data class ColdChainDevice(
    val id: Int,
    val name: String,
    var status: DeviceStatus,
    var temperature: String,
    var humidity: String,
    var oxygenLevel: String,
    val location: String,
    var lastUpdate: Date,
    val latLng: LatLng?,
    var speed: String? = null
)

// 设备状态枚举
enum class DeviceStatus(val displayName: String) {
    NORMAL("正常"),
    WARNING("警告"),
    ERROR("异常")
}

// 原始数据点（每5秒一条）
data class DeviceDataPoint(
    val deviceId: Int,
    val timestamp: Long,
    val status: DeviceStatus,
    val temperature: Double,
    val humidity: Double,
    val oxygenLevel: Double,
    val location: LatLng?
)

// 状态时间段
data class StatusPeriod(
    val deviceId: Int,
    val status: DeviceStatus,
    val startTime: Long,
    val endTime: Long,
    val duration: String, // 格式化的持续时间
    val averageTemperature: Double,
    val averageHumidity: Double,
    val averageOxygen: Double,
    val locationChanges: List<LocationPoint> // 该时间段内的位置变化
)

// 位置点
data class LocationPoint(
    val latLng: LatLng,
    val timestamp: Long,
    val status: DeviceStatus
)

// 轨迹数据
data class DeviceTrack(
    val deviceId: Int,
    val deviceName: String,
    val trackPoints: List<TrackPoint>,
    val totalDistance: Double, // 总距离（米）
    val avgSpeed: Double,      // 平均速度（km/h）
    val startTime: Long,
    val endTime: Long
)

// 轨迹点
data class TrackPoint(
    val latLng: LatLng,
    val timestamp: Long,
    val speed: Double, // km/h
    val status: DeviceStatus
)
```

### 4.2 Room数据库实体
```kotlin
// 设备实体
@Entity(tableName = "device_table")
data class DeviceEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val deviceName: String,
    val status: Int,
    val temperature: String,
    val humidity: String,
    val oxygenLevel: String,
    val location: String,
    val lastUpdate: Date,
    val latitude: Double,
    val longitude: Double,
    val speed: String? = null
)

// 设备历史数据实体
@Entity(tableName = "device_history_table")
data class DeviceHistoryEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val deviceId: Int,
    val deviceName: String,
    val timestamp: Long,
    val status: Int,
    val temperature: Double,
    val humidity: Double,
    val oxygenLevel: Double,
    val latitude: Double,
    val longitude: Double,
    val speed: Double? = null
)
```

## 五、技术实现细节

### 5.1 MQTT连接配置
```kotlin
// 阿里云IoT平台连接参数
private val PRODUCTKEY = "k21inrJttUu"
private var DEVICENAME = "android"
private val DEVICESECRET = "26b9547a2fa381c978868c7b578c9271"
private val PRODUCTSECRET = ""
private val PORT="1883"
val params: LinkKitInitParams = LinkKitInitParams()
var hosturl="iot-06z00ccayws04qj.mqtt.iothub.aliyuncs.com:"+PORT
val InstanceID="iot-06z00ccayws04qj"

// 初始化MQTT连接参数
fun deviceConnect() {
    // 设备信息配置
    var deviceinfo= DeviceInfo()
    deviceinfo.productKey=PRODUCTKEY
    deviceinfo.deviceName=DEVICENAME
    deviceinfo.deviceSecret=DEVICESECRET
    deviceinfo.productSecret=PRODUCTSECRET
    params.deviceInfo = deviceinfo;

    // 全局默认域名
    val userData = IoTApiClientConfig()
    params.connectConfig = userData

    // 物模型缓存
    val propertyValues: MutableMap<String?, ValueWrapper<*>?> = HashMap<String?, ValueWrapper<*>?>()
    params.propertyValues = propertyValues

    // MQTT客户端配置
    val clientConfig = IoTMqttClientConfig()
    clientConfig.receiveOfflineMsg = true // 接收离线消息
    clientConfig.channelHost = hosturl
    params.mqttClientConfig = clientConfig

    // 初始化连接
    LinkKit.getInstance().init(applicationContext, params, object : ILinkKitConnectListener {
        override fun onError(p0: AError?) {
            // 连接失败处理
        }
        override fun onInitDone(p0: Any?) {
            // 连接成功处理
        }
    })
}
```

### 5.2 数据解析与处理
```kotlin
private fun parseAndHandleMessage(jsonString: String) {
    PerformanceMonitor.measureExecutionTime("消息解析") {
        try {
            val rootObject = JSONObject(jsonString)
            Log.d(TAG, "rootObject内容: $rootObject")
            val deviceId = rootObject.optString("deviceName")
            
            // 处理所有设备数据，支持自动添加新设备
            if (deviceId.isNullOrEmpty()) {
                Log.e(TAG, "设备名称为空，忽略消息")
                return@measureExecutionTime
            }
            
            val dataObject = rootObject.optJSONObject("items")
            Log.d(TAG, "dataObject内容: $dataObject")
            if (dataObject != null) {
                // 解析车内温度
                val temperature = dataObject.optJSONObject("VehInsideTemp")?.optDouble("value")?.toString()+"°C"
                // 解析湿度
                val humidity = dataObject.optJSONObject("mhumi")?.optInt("value")?.toString()+"%"
                // 解析速度
                val speed = dataObject.optJSONObject("VehSpeed")?.optDouble("value")?.toFloat()?.toString()+"km/h"
                // 解析氧气含量
                val oxygenLevel = dataObject.optJSONObject("O2Content")?.optString("value")+"%"
                // 解析地理位置
                val geoLocation = dataObject.optJSONObject("GeoLocation")
                var locationStr = "null"
                var latLng = LatLng(0.0, 0.0)
                if (geoLocation != null) {
                    Log.d(TAG, "GeoLocation对象: $geoLocation")
                    val geoValue = geoLocation.optJSONObject("value")
                    if (geoValue != null) {
                        Log.d(TAG, "GeoLocation.value对象: $geoValue")
                        // 直接获取经纬度值，使用强制类型转换确保正确性
                        val longitudeValue = geoValue.get("Longitude")
                        val latitudeValue = geoValue.get("Latitude")
                        Log.d(TAG, "Longitude值: $longitudeValue, 类型: ${longitudeValue.javaClass.name}")
                        Log.d(TAG, "Latitude值: $latitudeValue, 类型: ${latitudeValue.javaClass.name}")
                        
                        // 转换为Double类型
                        val longitude = when (longitudeValue) {
                            is Number -> longitudeValue.toDouble()
                            is String -> longitudeValue.toDoubleOrNull() ?: 0.0
                            else -> 0.0
                        }
                        val latitude = when (latitudeValue) {
                            is Number -> latitudeValue.toDouble()
                            is String -> latitudeValue.toDoubleOrNull() ?: 0.0
                            else -> 0.0
                        }
                        val altitude = geoValue.optDouble("Altitude", 0.0)
                        val coordinateSystem = geoValue.optInt("CoordinateSystem", 2)
                           
                        // 验证坐标是否有效（非零且非NaN）
                        val isValidCoordinate = longitude != 0.0 && latitude != 0.0 && !longitude.isNaN() && !latitude.isNaN()
                        if (isValidCoordinate) {
                            // 构建位置字符串
                            locationStr = "经度: $longitude, 纬度: $latitude, 海拔: $altitude, 坐标系: ${if (coordinateSystem == 1) "WGS_84" else "GCJ_02"}"
                            // 创建LatLng对象
                            latLng = LatLng(latitude, longitude)
                            Log.d(TAG, "解析得到的有效经纬度: $latLng")
                        } else {
                            Log.w(TAG, "解析得到无效坐标: 经度=$longitude, 纬度=$latitude")
                        }
                    }
                }
                
                Log.d(TAG, "解析结果 -> 设备: $deviceId, 温度: $temperature, 湿度: $humidity, 速度: $speed, 氧气浓度: $oxygenLevel, 位置: $locationStr")

                // 创建 ColdChainDevice 对象，使用设备名称的哈希值作为唯一id
                val coldChainDevice = ColdChainDevice(
                    id = deviceId.hashCode(),
                    name = deviceId,
                    status = com.example.dgb.DeviceStatus.ERROR,
                    temperature = temperature,
                    oxygenLevel = oxygenLevel,
                    humidity = humidity,
                    location = locationStr,
                    lastUpdate = Date(),
                    latLng = latLng,
                    speed = speed
                )
                coldChainDevice.status = when {
                    (coldChainDevice.oxygenLevel.replace("%", "").toDoubleOrNull() ?: 0.0) < 18.5 -> com.example.dgb.DeviceStatus.ERROR
                    (coldChainDevice.temperature.replace("°C", "").toDoubleOrNull() ?: 25.0) >5.0 -> com.example.dgb.DeviceStatus.ERROR
                    (coldChainDevice.humidity.replace("%", "").toDoubleOrNull() ?: 25.0) >50.0 -> com.example.dgb.DeviceStatus.ERROR
                    (coldChainDevice.oxygenLevel.replace("%", "").toDoubleOrNull() ?: 0.0) < 19.5 -> com.example.dgb.DeviceStatus.WARNING
                    (coldChainDevice.temperature.replace("°C", "").toDoubleOrNull() ?: 25.0) >0.0 -> com.example.dgb.DeviceStatus.WARNING
                    (coldChainDevice.humidity.replace("%", "").toDoubleOrNull() ?: 25.0) >30.0 -> com.example.dgb.DeviceStatus.WARNING
                    else -> com.example.dgb.DeviceStatus.NORMAL
                }
                updateDeviceData(coldChainDevice)
            }
        } catch (e: Exception) {
            Log.e(TAG, "解析JSON失败", e)
            eventLogger.logException(
                type = com.example.dgb.data.EventType.NETWORK_ERROR,
                message = "解析设备数据JSON失败",
                exception = e
            )
        }
    }
}
```

### 5.3 设备轨迹存储与显示

#### 5.3.1 轨迹数据存储
```kotlin
// MqttService中定义的轨迹存储容器
public val deviceTrackMap = ConcurrentHashMap<String, MutableList<TrackPoint>>()

// 轨迹点数据模型
data class TrackPoint(
    val latLng: LatLng,
    val timestamp: Long,
    val speed: Double,
    val status: DeviceStatus
)

// 更新设备数据并记录轨迹
private fun updateDeviceData(target: ColdChainDevice) {
    // 使用deviceMap的原子操作进行设备数据更新
    val updatedDevice = deviceMap.compute(target.name) { _, existingDevice ->
        if (existingDevice != null) {
            // 更新现有设备的属性
            existingDevice.apply {
                if (target.temperature != "null") temperature = target.temperature
                if (target.oxygenLevel != "null") oxygenLevel = target.oxygenLevel
                if (target.location != "null") location = target.location
                if (target.lastUpdate != Date()) lastUpdate = target.lastUpdate
                if (target.latLng != LatLng(0.0, 0.0)) latLng = target.latLng
                if (target.speed != "null") speed = target.speed
                if (target.humidity != "null") humidity = target.humidity
                status = target.status
            }
        } else {
            // 添加新设备
            target
        }
    }
    
    // 记录设备轨迹数据（仅有效坐标）
    if (updatedDevice != null && updatedDevice.latLng.latitude != 0.0 && updatedDevice.latLng.longitude != 0.0 && !updatedDevice.latLng.latitude.isNaN() && !updatedDevice.latLng.longitude.isNaN()) {
        Log.d(TAG, "记录设备 ${updatedDevice.name} 的轨迹数据，位置: ${updatedDevice.latLng}")
        val trackPoint = TrackPoint(
            latLng = updatedDevice.latLng,
            timestamp = updatedDevice.lastUpdate.time,
            speed = updatedDevice.speed?.replace("km/h", "")?.toDoubleOrNull() ?: 0.0,
            status = updatedDevice.status
        )
        
        // 获取或创建设备的轨迹列表
        val trackList = deviceTrackMap.computeIfAbsent(updatedDevice.name) { mutableListOf() }
        
        // 添加新轨迹点
        trackList.add(trackPoint)
        Log.d(TAG, "设备 ${updatedDevice.name} 的轨迹点数量: ${trackList.size}")
        
        // 限制轨迹点数量，保留最近的100个点（优化内存）
        if (trackList.size > 100) {
            trackList.removeAt(0)
            Log.d(TAG, "设备 ${updatedDevice.name} 的轨迹点数量超过100，已移除最早的点")
        }
    }
    
    // 保存数据到数据库（在协程中执行）
    if (updatedDevice != null) {
        mqttCoroutineScope.launch(Dispatchers.IO) {
            saveDeviceDataToDatabase(updatedDevice)
        }
    }
    
    // 通知UI更新
    ServiceDataRepository.notifyFragmentToUpdate()
}
```

#### 5.3.2 轨迹数据显示
```kotlin
// HomeFragment中显示设备轨迹的方法
private fun showDeviceTrack(deviceId: Int, deviceName: String) {
    // 直接使用设备名称从MqttService获取轨迹数据
    Log.d("HomeFragment", "尝试显示设备 $deviceName 的轨迹，deviceId: $deviceId")
    
    // 检查deviceTrackMap的整体状态
    Log.d("HomeFragment", "deviceTrackMap 包含 ${MqttService.deviceTrackMap.size} 个设备的轨迹数据")
    
    // 查看所有有轨迹数据的设备名称
    MqttService.deviceTrackMap.forEach { (name, points) ->
        Log.d("HomeFragment", "  - 设备 $name 有 ${points.size} 个轨迹点")
    }
    
    // 直接通过设备名称获取轨迹数据
    val trackPoints = MqttService.deviceTrackMap[deviceName]
    if (trackPoints != null && trackPoints.isNotEmpty()) {
        Log.d("HomeFragment", "找到设备 $deviceName 的轨迹数据，共 ${trackPoints.size} 个点")
        // 使用MapUtils绘制轨迹
        MapUtils.drawVehicleTrack(aMap, trackPoints)
        // 显示轨迹信息
        showTrackInfo(deviceName, trackPoints)
    } else {
        Log.d("HomeFragment", "未找到设备 $deviceName 的轨迹数据")
        Toast.makeText(activity, "该设备暂无轨迹数据", Toast.LENGTH_SHORT).show()
    }
}

// MapUtils中绘制轨迹的方法
fun drawVehicleTrack(aMap: AMap, trackPoints: List<TrackPoint>) {
    // 清除已有的轨迹
    aMap.clear()
    
    if (trackPoints.isEmpty()) return
    
    val polylineOptions = PolylineOptions()
    
    // 根据轨迹点状态设置颜色
    val trackColor = when (trackPoints.last().status) {
        DeviceStatus.NORMAL -> Color.GREEN
        DeviceStatus.WARNING -> Color.YELLOW
        DeviceStatus.ERROR -> Color.RED
    }
    
    // 添加所有轨迹点
    trackPoints.forEach { point ->
        polylineOptions.add(point.latLng)
    }
    
    // 设置轨迹样式
    polylineOptions.width(8f)
        .color(trackColor)
        .geodesic(false)
    
    // 添加轨迹到地图
    aMap.addPolyline(polylineOptions)
    
    // 在轨迹起点和终点添加标记
    val startPoint = trackPoints.first().latLng
    val endPoint = trackPoints.last().latLng
    
    // 添加起点标记
    aMap.addMarker(MarkerOptions()
        .position(startPoint)
        .icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_GREEN))
        .title("起点")
        .snippet(Date(trackPoints.first().timestamp).toString()))
    
    // 添加终点标记
    aMap.addMarker(MarkerOptions()
        .position(endPoint)
        .icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED))
        .title("终点")
        .snippet(Date(trackPoints.last().timestamp).toString()))
    
    // 调整地图视角以显示完整轨迹
    val bounds = LatLngBounds.Builder()
    trackPoints.forEach { point ->
        bounds.include(point.latLng)
    }
    aMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds.build(), 100))
}
```

### 5.4 地图功能实现（含设备集群）
```kotlin
// 初始化地图
mapView = view.findViewById(R.id.map_view)
mapView.onCreate(savedInstanceState)
aMap = mapView.map

// 设置地图基本配置
aMap?.let {
    it.uiSettings.isZoomControlsEnabled = true
    it.uiSettings.isCompassEnabled = true
    it.uiSettings.isMyLocationButtonEnabled = true
    
    // 初始化MapUtils
    mapUtils = MapUtils(it)
    
    // 添加地图缩放级别监听，实现多设备聚合显示
    it.setOnCameraChangeListener(object : AMap.OnCameraChangeListener {
        override fun onCameraChange(p0: com.amap.api.maps.model.CameraPosition?) {
            // 相机位置变化时触发
        }
        
        override fun onCameraChangeFinish(cameraPosition: com.amap.api.maps.model.CameraPosition?) {
            cameraPosition?.let {
                // 相机位置变化结束后，显示聚合标记
                mapUtils.showDeviceClusters(deviceList)
            }
        }
    })
}
```

### 5.5 Room数据库实现
```kotlin
// 数据库定义
@Database(entities = [DeviceEntity::class, DeviceHistoryEntity::class, EventLogEntity::class], version = 3)
abstract class DeviceDatabase : RoomDatabase() {
    abstract fun deviceDao(): DeviceDao
    abstract fun deviceHistoryDao(): DeviceHistoryDao
    abstract fun eventLogDao(): EventLogDao
    
    companion object {
        @Volatile
        private var INSTANCE: DeviceDatabase? = null
        
        fun getDatabase(context: Context): DeviceDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    DeviceDatabase::class.java,
                    "device_database"
                )
                .fallbackToDestructiveMigration() // 开发阶段使用，生产环境应配置迁移策略
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

### 5.6 数据对比分析功能实现

#### 5.6.1 数据分析主页面
```kotlin
// 数据报表与分析页面
class DataAnalysisActivity : AppCompatActivity() {
    
    // 视图组件
    private lateinit var deviceSpinner: Spinner
    private lateinit var timeRangeSpinner: Spinner
    private lateinit var parameterSpinner: Spinner
    private lateinit var chartContainer: LinearLayout
    private lateinit var statisticsContainer: LinearLayout
    private lateinit var generateReportBtn: Button
    private lateinit var exportCsvBtn: Button
    private lateinit var multiDeviceContainer: LinearLayout
    private lateinit var deviceListContainer: LinearLayout
    private lateinit var compareDevicesBtn: Button
    
    // 数据和工具
    private lateinit var historyViewModel: DeviceHistoryViewModel
    private lateinit var chartUtils: ChartUtils
    private lateinit var reportGenerator: ReportGenerator
    
    // 当前显示的图表
    private var currentChart: LineChart? = null
    
    // 设备列表
    private var devices: List<DeviceEntity> = emptyList()
    private var selectedDeviceId: Int? = null
    private val selectedDevicesForComparison: MutableList<DeviceEntity> = mutableListOf()
    
    // 时间范围选项
    private val timeRangeOptions = arrayOf(
        "最近1小时",
        "最近6小时",
        "最近12小时",
        "最近24小时",
        "最近7天",
        "自定义范围"
    )
    
    // 参数类型选项
    private val parameterOptions = arrayOf(
        "温度",
        "湿度",
        "氧气浓度",
        "多参数对比",
        "多设备参数对比",
        "温度仪表盘",
        "湿度仪表盘",
        "氧气浓度仪表盘"
    )
    
    // ... 其他初始化和方法 ...
    
    /**
     * 加载多设备数据并更新图表
     */
    private fun loadMultiDeviceDataAndUpdateChart() {
        if (selectedDevicesForComparison.isEmpty()) {
            Toast.makeText(this, "请选择至少一个设备", Toast.LENGTH_SHORT).show()
            return
        }
        
        // 获取时间范围
        val timeRangePosition = timeRangeSpinner.selectedItemPosition
        val timeRange = calculateTimeRange(timeRangePosition)
        
        // 显示加载提示
        Toast.makeText(this, "正在加载设备数据...", Toast.LENGTH_SHORT).show()
        
        // 加载所有选中设备的数据
        val deviceDataMap = mutableMapOf<DeviceEntity, List<DeviceHistoryEntity>>()
        var devicesLoaded = 0
        
        for (device in selectedDevicesForComparison) {
            historyViewModel.getDeviceHistoriesInTimeRange(device.deviceId, timeRange.startTime, timeRange.endTime) { histories ->
                deviceDataMap[device] = histories
                devicesLoaded++
                
                // 当所有设备数据都加载完成后，更新图表
                if (devicesLoaded == selectedDevicesForComparison.size) {
                    updateMultiDeviceComparisonChart(deviceDataMap)
                }
            }
        }
    }
    
    /**
     * 更新多设备对比图表
     */
    private fun updateMultiDeviceComparisonChart(deviceDataMap: Map<DeviceEntity, List<DeviceHistoryEntity>>) {
        // 清空容器
        chartUtils.clearChart(chartContainer)
        
        // 检查是否有设备数据
        if (deviceDataMap.isEmpty()) {
            Toast.makeText(this, "无设备数据可对比", Toast.LENGTH_SHORT).show()
            return
        }
        
        // 获取当前选择的参数类型（温度、湿度、氧气浓度）
        val parameterType = when (timeRangeSpinner.selectedItemPosition % 3) {
            0 -> ChartUtils.ParameterType.TEMPERATURE
            1 -> ChartUtils.ParameterType.HUMIDITY
            2 -> ChartUtils.ParameterType.OXYGEN_LEVEL
            else -> ChartUtils.ParameterType.TEMPERATURE
        }
        
        // 创建多设备对比图表，将DeviceEntity映射转换为id映射
        val deviceIdDataMap = deviceDataMap.mapKeys { it.key.deviceId }
        chartUtils.createMultiDeviceParameterChart(chartContainer, deviceIdDataMap, parameterType)
        
        // 更新统计信息
        updateMultiDeviceStatistics(deviceDataMap)
    }
}
```

#### 5.5.2 多设备参数对比图表实现
```kotlin
/**
 * 创建多设备参数对比图表
 * @param container 图表容器布局
 * @param deviceDataMap 设备数据映射，key为设备ID，value为该设备的历史数据
 * @param parameterType 参数类型
 * @return 创建的折线图
 */
fun createMultiDeviceParameterChart(
    container: LinearLayout,
    deviceDataMap: Map<Int, List<DeviceHistoryEntity>>,
    parameterType: ParameterType
): LineChart {
    // 创建折线图实例
    val chart = LineChart(context)
    
    // 设置图表尺寸
    val params = LinearLayout.LayoutParams(
        ViewGroup.LayoutParams.MATCH_PARENT,
        ViewGroup.LayoutParams.MATCH_PARENT
    )
    chart.layoutParams = params
    
    // 配置图表基本属性
    configureChart(chart)
    
    // 准备数据集
    val dataSets = deviceDataMap.entries.mapIndexed { index, entry ->
        val deviceId = entry.key
        val histories = entry.value
        
        // 按时间排序
        val sortedHistories = histories.sortedBy { it.timestamp }
        
        // 准备数据点
        val entries = sortedHistories.mapIndexed { entryIndex, history ->
            val value = when (parameterType) {
                ParameterType.TEMPERATURE -> history.temperature
                ParameterType.HUMIDITY -> history.humidity
                ParameterType.OXYGEN_LEVEL -> history.oxygenLevel
            }
            Entry(entryIndex.toFloat(), value.toFloat())
        }
        
        // 创建数据集
        val colors = listOf(0xFFFF5722, 0xFF2196F3, 0xFF4CAF50, 0xFF9C27B0, 0xFFFFEB3B, 0xFFE91E63)
        val color = colors[index % colors.size]
        createLineDataSet(entries, "设备$deviceId", color)
    }
    
    // 设置数据
    val data = LineData(dataSets)
    chart.data = data
    
    // 更新图表
    chart.invalidate()
    
    // 添加到容器
    container.addView(chart)
    
    return chart
}
```

#### 5.5.3 统计分析工具类
```kotlin
// 统计分析工具类，提供多维度的数据统计计算功能
class StatisticsAnalyzer {
    // 时间格式化器
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    
    // 计算基础统计信息（平均值、最大值、最小值、总和、数据点数量）
    fun calculateBasicStatistics(values: List<Double>): BasicStatistics {
        if (values.isEmpty()) {
            return BasicStatistics(0.0, 0.0, 0.0, 0.0, 0)
        }
        
        val count = values.size
        val sum = values.sum()
        val average = sum / count
        val max = values.maxOrNull() ?: 0.0
        val min = values.minOrNull() ?: 0.0
        
        return BasicStatistics(average, max, min, sum, count)
    }
    
    // 按时间段聚合数据
    fun aggregateByTime(histories: List<DeviceHistoryEntity>, intervalMillis: Long): Map<Long, List<DeviceHistoryEntity>> {
        val aggregatedMap = mutableMapOf<Long, MutableList<DeviceHistoryEntity>>()
        
        for (history in histories) {
            // 计算所属的时间间隔键
            val intervalKey = history.timestamp - (history.timestamp % intervalMillis)
            // 将数据添加到对应时间间隔的列表中
            aggregatedMap.computeIfAbsent(intervalKey) { mutableListOf() }.add(history)
        }
        
        return aggregatedMap
    }
    
    // 计算设备状态分布
    fun calculateStatusDistribution(histories: List<DeviceHistoryEntity>): Map<DeviceStatus, Int> {
        val statusMap = mutableMapOf<DeviceStatus, Int>()
        
        for (history in histories) {
            val status = when {
                history.temperature > 5.0 || history.humidity > 50.0 || history.oxygenLevel < 18.5 -> DeviceStatus.ERROR
                history.temperature > 0.0 || history.humidity > 30.0 || history.oxygenLevel < 19.5 -> DeviceStatus.WARNING
                else -> DeviceStatus.NORMAL
            }
            statusMap[status] = statusMap.getOrDefault(status, 0) + 1
        }
        
        return statusMap
    }
    
    // 基础统计数据类
    data class BasicStatistics(
        val average: Double,
        val max: Double,
        val min: Double,
        val sum: Double,
        val count: Int
    )
}
```

### 5.6 事件日志记录
```kotlin
// 记录事件
eventLogger.info(
    type = EventType.SYSTEM_EVENT,
    message = "MQTT服务已启动"
)

// 记录异常
eventLogger.logException(
    type = EventType.ERROR_EVENT,
    message = "MQTT连接失败",
    exception = e
)
```

## 六、设备状态判断逻辑

设备状态根据以下规则自动判断：

| 参数类型 | 正常范围 | 警告范围 | 异常范围 |
|---------|---------|---------|---------|
| 温度    | ≤0°C     | 0°C~5°C  | >5°C     |
| 湿度    | ≤30%     | 30%~50%  | >50%     |
| 氧气浓度 | ≥19.5%   | 18.5%~19.5% | <18.5% |

注：当任一参数达到异常范围时，设备状态为异常；当参数在警告范围但未达到异常范围时，设备状态为警告；所有参数均在正常范围时，设备状态为正常。

## 七、系统配置

### 7.1 高德地图配置
在AndroidManifest.xml中配置高德地图API密钥：
```xml
<meta-data
    android:name="com.amap.api.v2.apikey"
    android:value="d593d43d3617397a64454494f3d76134" />
```

### 7.2 权限配置
```xml
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

### 7.3 依赖配置
在app/build.gradle.kts中配置主要依赖：
```kotlin
dependencies {
    // 阿里云LinkKit
    implementation("com.aliyun.alink.linksdk:lp-iot-linkkit:1.7.3.8")
    
    // 高德地图
    implementation(files("libs/AMap3DMap_10.1.600_AMapSearch_9.7.4_AMapLocation_6.5.1_20251020.jar"))
    
    // Jetpack组件
    implementation(libs.androidx.lifecycle.livedata.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.ktx)
    implementation(libs.androidx.room.runtime)
    ksp(libs.androidx.room.compiler)
    
    // 协程
    implementation(libs.kotlinx.coroutines.android)
    
    // 其他依赖...
}
```

## 八、使用说明

### 8.1 应用启动与登录
1. 安装并启动应用
2. 在登录界面输入用户名和密码
3. 点击登录按钮进入主界面

### 8.2 首页功能
1. 查看所有设备在地图上的位置，支持缩放查看设备集群
2. 点击设备标记查看设备基本信息
3. 浏览设备卡片，快速了解设备状态与环境参数

### 8.3 设备管理
1. 查看所有注册设备的列表
2. 使用搜索框查找特定设备
3. 点击筛选按钮按状态筛选设备
4. 点击设备卡片查看历史数据
5. 长按设备卡片查看详细信息
6. 使用批量选择功能管理多个设备

### 8.4 事件日志查看
1. 在底部导航栏点击日志图标进入日志页面
2. 查看系统事件、错误信息和操作记录
3. 根据事件类型筛选日志

### 8.5 异常处理
1. 当设备状态为警告或异常时，卡片会显示相应颜色提示
2. 点击异常设备可查看具体异常参数
3. 系统会自动记录异常事件，可在日志页面查询

### 8.6 数据对比分析
1. 在底部导航栏点击数据分析图标进入数据分析页面
2. **单设备数据分析**：
   - 选择设备、时间范围和参数类型（温度、湿度、氧气浓度）
   - 查看数据趋势图和统计信息
   - 支持多参数对比（同时查看温度、湿度、氧气浓度趋势）

3. **多设备数据对比**：
   - 在参数类型中选择"多设备参数对比"
   - 从设备列表中选择至少两个设备
   - 点击"对比选中设备"按钮查看对比图表
   - 系统会自动显示各设备的相同参数趋势对比

4. **数据可视化选项**：
   - 温度/湿度/氧气浓度仪表盘显示
   - 数据统计图表（平均值、最大值、最小值、异常率）
   - 设备状态分布饼图

5. **报表与导出**：
   - 点击"生成报表"按钮生成数据分析报告
   - 点击"导出CSV"按钮将数据导出为CSV格式

## 九、项目结构

```
├── app/
│   ├── src/
│   │   └── main/
│   │       ├── java/com/example/dgb/
│   │       │   ├── MainActivity.kt       // 主界面
│   │       │   ├── LoginActivity.kt      // 登录界面
│   │       │   ├── HomeFragment.kt       // 首页地图
│   │       │   ├── DeviceFragment.kt     // 设备管理
│   │       │   ├── UserFragment.kt       // 用户中心
│   │       │   ├── MqttService.kt        // MQTT服务
│   │       │   ├── ColdChainApplication.kt // 应用入口
│   │       │   ├── DataModels.kt         // 数据模型
│   │       │   ├── MapUtils.kt           // 地图工具类
│   │       │   ├── data/                 // 数据层
│   │       │   │   ├── AlertService.kt           // 告警服务
│   │       │   │   ├── DeviceDao.kt              // 设备DAO
│   │       │   │   ├── DeviceDatabase.kt         // 数据库定义
│   │       │   │   ├── DeviceEntity.kt           // 设备实体
│   │       │   │   ├── DeviceHistoryDao.kt       // 历史数据DAO
│   │       │   │   ├── DeviceHistoryEntity.kt    // 历史数据实体
│   │       │   │   ├── DeviceHistoryRepository.kt // 历史数据仓库
│   │       │   │   ├── DeviceHistoryViewModel.kt // 历史数据视图模型
│   │       │   │   ├── DeviceViewModel.kt        // 设备视图模型
│   │       │   │   ├── EventLogDao.kt            // 事件日志DAO
│   │       │   │   ├── EventLogger.kt            // 事件日志记录器
│   │       │   │   ├── GlobalExceptionHandler.kt // 全局异常处理
│   │       │   │   ├── LoginDataSource.kt        // 登录数据源
│   │       │   │   ├── LoginRepository.kt        // 登录仓库
│   │       │   │   ├── PermissionService.kt      // 权限服务
│   │       │   │   ├── StatisticsAnalyzer.kt     // 统计分析器
│   │       │   │   ├── SyncService.kt            // 同步服务
│   │       │   │   └── model/                    // 模型目录
│   │       │   └── ui/                     // UI层
│   │       │       ├── EventLogFragment.kt       // 事件日志界面
│   │       │       ├── charts/                   // 图表相关
│   │       │       └── theme/                    // 主题相关
│   │       ├── res/                        // 资源文件
│   │       │   ├── layout/                 // 布局文件
│   │       │   ├── drawable/               // 图片资源
│   │       │   └── values/                 // 字符串、颜色等资源
│   │       └── AndroidManifest.xml         // 应用配置
│   ├── libs/                               // 第三方库
│   │   └── AMap3DMap_10.1.600_AMapSearch_9.7.4_AMapLocation_6.5.1_20251020.jar
│   └── build.gradle.kts                    // 模块配置
├── AMap_Android_SDK_All/                   // 高德地图SDK资源
├── gradle/                                 // Gradle配置
└── build.gradle.kts                        // 项目配置
```

## 十、总结与展望

### 10.1 项目总结
本项目成功实现了一个基于物联网的冷藏运输车环境监测与智能管控系统的Android应用，具有以下特点：
- **实时监控**：能够实时获取并显示冷藏运输设备的环境参数与位置信息
- **智能预警**：根据预设阈值自动判断设备状态，实现异常预警
- **数据持久化**：使用Room数据库实现本地数据存储，支持离线查看
- **设备集群**：地图界面支持设备集群显示，提升多设备查看体验
- **批量操作**：支持设备批量选择和管理，提高操作效率
- **事件日志**：完善的事件记录系统，便于问题追踪和系统监控
- **全局异常处理**：提高应用稳定性，防止意外崩溃
- **友好界面**：采用现代化的Material Design风格，操作简单直观
- **稳定可靠**：基于阿里云IoT平台，确保数据传输的稳定性与安全性

### 10.2 未来展望
1. **扩展监控参数**：增加更多环境参数的监控，如二氧化碳浓度、光照强度等
2. **数据分析功能**：增加数据统计与分析功能，生成报表与趋势图
3. **多渠道告警**：实现短信、邮件等多渠道告警功能
4. **离线功能**：增强离线数据存储与同步功能
5. **批量管理**：进一步完善批量设备管理与配置功能
6. **数据可视化**：优化数据图表展示，提升用户体验
7. **用户权限管理**：增加多角色用户权限控制

## 十一、附录

### 11.1 相关文档
- [阿里云IoT平台文档](https://help.aliyun.com/document_detail/69893.html)
- [高德地图Android SDK文档](https://lbs.amap.com/api/android-sdk/guide)
- [Android Jetpack文档](https://developer.android.com/jetpack)
- [Room数据库文档](https://developer.android.com/training/data-storage/room)

### 11.2 版本历史
- **v1.0**：基础功能实现，包括实时监控、设备管理、MQTT通信等
- **v2.0**：增加数据持久化、事件日志系统、设备集群显示
- **v3.0**：增加批量操作功能、全局异常处理、完善MVVM架构

---
**文档撰写日期**：2025年12月14日
**项目负责人**：[项目负责人姓名]
**开发团队**：[开发团队名称]